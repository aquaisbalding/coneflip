<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spinning Traffic Cone</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #world {
            display: block;
            position: absolute;
            height: 100%;
            width: 100%;
            z-index: 0;

        }

        #confetti-canvas {
            display: block;
            position: absolute;
            height: 100%;
            width: 100%;
            z-index: 2;

        }
    </style>
</head>

<body>
    <canvas id="confetti-canvas"></canvas>
    <canvas id="world"></canvas>

    <!-- Matter.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tsparticles/confetti@3.0.3/tsparticles.confetti.bundle.min.js"></script>

    <!-- Sound effects --> 
    <audio id="launchSound" src="launch.mp3"></audio>
    <audio id="spinSound" src="flip.mp3" loop></audio>
    <audio id="bounceSound" src="thud.mp3"></audio>
    <audio id="coolSound" src="launch.mp3"></audio>

    <script>
        // Set up the Matter.js engine and world
        const { Engine, Render, Runner, Bodies, Composite, Body, Vertices, Events } = Matter;

        const engine = Engine.create();
        const world = engine.world;

        // Gravity setting
        engine.world.gravity.y = 1.0;

        const canvas = document.getElementById('world');
        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: 'none'
            }
        });

        Render.run(render);

        const runner = Runner.create({
            delta: 1000 / 60
        });
        Runner.run(runner, engine);

        // Ground
        const ground = Bodies.rectangle(window.innerWidth / 2, window.innerHeight - 20, window.innerWidth, 20, {
            isStatic: true,
            render: {
                fillStyle: 'transparent',
                strokeStyle: 'transparent'
            }
        });
        Composite.add(world, ground);

        // Cone vertices and scaling
        const coneVertices = Vertices.fromPath('0 6200.83 992.78 6200.83 2481.95 0 3203.97 0 4723.22 6200.83 5806.26 6200.83 5806.26 7795.3 0 7795.3');
        const scaledVertices = coneVertices.map(vertex => ({
            x: vertex.x * 0.02,
            y: vertex.y * 0.02
        }));

        const trafficCone = Bodies.fromVertices(window.innerWidth / 2, window.innerHeight - 85, [scaledVertices], {
            restitution: 0.2,
            render: {
                sprite: {
                    texture: 'cone.png',
                    xScale: 0.02,
                    yScale: 0.02,
                },
                strokeStyle: 'black',
                lineWidth: 2
            }
        });

        Composite.add(world, trafficCone);

        const upwardForceMultiplier = 0.7;

        const launchSound = document.getElementById('launchSound');
        const spinSound = document.getElementById('spinSound');
        const bounceSound = document.getElementById('bounceSound');
        const coolSound = document.getElementById('coolSound');

        let uprightTimer = null;

        // Apply random force and spin to the cone
        function applyRandomUpwardForceAndSpin(body) {
            clearTimeout(uprightTimer);
            const forceMagnitude = upwardForceMultiplier + Math.random() * 0.05;
            const horizontalForce = (Math.random() - 0.5) * 0.1;
            const force = {
                x: horizontalForce,
                y: -forceMagnitude
            };
            Body.applyForce(body, { x: body.position.x, y: body.position.y }, force);

            launchSound.play();

            const minAngularVelocity = 0.2;
            const additionalAngularVelocity = Math.random() * 0.8;
            const angularVelocity = minAngularVelocity + additionalAngularVelocity;
            Body.setAngularVelocity(body, angularVelocity * (Math.random() > 0.5 ? 1 : -1));

            spinSound.play();
        }

        function checkIfUpright(body) {
            // Normalize the angle to be within [-π, π]
            let angle = body.angle % (2 * Math.PI);
            if (angle > Math.PI) angle -= 2 * Math.PI;
            if (angle < -Math.PI) angle += 2 * Math.PI;

            // Check if angle is within upright range
            const isUprightNow = Math.abs(angle) < 0.1 || Math.abs(Math.abs(angle) - Math.PI) < 0.1;

            console.log("ANGLE: " + angle);

            if (isUprightNow && Math.abs(body.angularVelocity) < 0.05 && Math.abs(body.velocity.x) < 0.05 && Math.abs(body.velocity.y) < 0.05) {
                console.log('Upright and stationary detected, starting timer...');
                uprightTimer = setTimeout(() => {
                    // Recheck if it is still upright and stationary after 500ms
                    if (Math.abs(angle) < 0.1 || Math.abs(Math.abs(angle) - Math.PI) < 0.1) {
                        console.log('Cone has been upright and stationary for 500ms');
                        coolSound.play();
                        clearInterval(checktimer);
                        playConfetti();
                    }
                }, 500); 
            }
        }

        let checktimer;

        // Set initial cone position and launch
        Body.setPosition(trafficCone, { x: window.innerWidth / 2, y: window.innerHeight - 85 });
        Body.setVelocity(trafficCone, { x: 0, y: 0 });
        Body.setAngularVelocity(trafficCone, 0);

        // Launch after 2 seconds
        setTimeout(() => {
            console.log("started");
            Events.on(engine, 'collisionStart', function (event) {
                bounceSound.play();
            });

            applyRandomUpwardForceAndSpin(trafficCone);
            checktimer = setInterval(function () {
                console.log("started");
                checkIfUpright(trafficCone);
            }, 1000);

        }, 2000);

        // Handle window resize
        window.addEventListener('resize', () => {
            Render.lookAt(render, {
                min: { x: 0, y: 0 },
                max: { x: window.innerWidth, y: window.innerHeight }
            });
        });



        // Stop spin sound when the cone stops spinning
        Events.on(engine, 'afterUpdate', function () {
            if (Math.abs(trafficCone.angularVelocity) < 0.05) {
                spinSound.pause();
            }
        });

        let playConfetti = () => {
            const count = 200,
                defaults = {
                    origin: { y: 0.7 },
                };

            function fire(particleRatio, opts) {
                confetti(
                    Object.assign({}, defaults, opts, {
                        particleCount: Math.floor(count * particleRatio),
                    })
                );
            }

            fire(0.25, {
                spread: 26,
                startVelocity: 55,
            });

            fire(0.2, {
                spread: 60,
            });

            fire(0.35, {
                spread: 100,
                decay: 0.91,
                scalar: 0.8,
            });

            fire(0.1, {
                spread: 120,
                startVelocity: 25,
                decay: 0.92,
                scalar: 1.2,
            });

            fire(0.1, {
                spread: 120,
                startVelocity: 45,
            });
        };

    </script>
</body>

</html>
